'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shake = undefined;

var _jsItertools = require('@aureooms/js-itertools');

var _jsGrammar = require('@aureooms/js-grammar');

const empty = {
  'type': 'node',
  'nonterminal': 'empty',
  'production': 'main',
  'children': []
};

const err = (nonterminal, production) => () => {
  throw new Error(`${nonterminal}.${production} should have been handled before`);
};

const t = _jsGrammar.ast.transform;
const m = (children, match, ctx) => _jsGrammar.ast.cmap(child => t(child, match, ctx), children);

const shake = exports.shake = {

  "blocks": {

    "add": (tree, match, ctx) => ({
      "type": "node",
      "nonterminal": "blocks",
      "production": "add",
      "children": m(tree.children, match, ctx)
    }),

    "end": () => empty

  },

  "block": {

    "text": tree => tree,

    "newif": () => empty,

    "ifcmd": (tree, match, ctx) => {

      const [ifcmd, block1, endif] = tree.children;
      const variable = ifcmd.buffer.substr(3);

      if (ctx.variables.has(variable)) {
        const flag = ctx.variables.get(variable);
        if (flag) return t(block1, match, ctx);else if (endif.production === "elsefi") {
          const [_else, block2, _fi] = endif.children;
          return t(block2, match, ctx);
        } else return empty;
      }

      return {
        'type': 'node',
        'nonterminal': 'block',
        'production': 'ifcmd',
        'children': (0, _jsItertools.chain)([[ifcmd], m([block1, endif], match, ctx)])
      };
    },

    "falsecmd": (tree, _, ctx) => {
      const [falsecmd] = tree.children;
      const buffer = falsecmd.buffer;
      const variable = buffer.substring(1, buffer.length - 5);
      ctx.variables.set(variable, false);
      return empty;
    },

    "truecmd": (tree, _, ctx) => {
      const [truecmd] = tree.children;
      const buffer = truecmd.buffer;
      const variable = buffer.substring(1, buffer.length - 4);
      ctx.variables.set(variable, true);
      return empty;
    },

    "comment": () => ({
      'type': 'leaf',
      'terminal': 'comment',
      'buffer': '%'
    }),

    "othercmd": (tree, match, ctx) => {
      const [othercmd, optstar, optargs, args] = tree.children;
      let cmd = othercmd.buffer;
      if (optstar.production === 'yes') cmd += '*';
      const hasoptargs = optargs.production === 'yes';
      const cmdargs = [];
      let arg_i = args;
      while (arg_i.production === 'add') {
        const [_open, arg, _close, argstail] = arg_i.children;
        cmdargs.push(arg);
        arg_i = argstail;
      }
      if (!hasoptargs && ctx.variables.has(cmd)) {
        // too hard to parse opt args currently
        const [nargs, expandsto] = ctx.variables.get(cmd);
        if (cmdargs.length !== nargs) throw new Error(`Command ${cmd} is defined with ${nargs} arguments but ${cmdargs.length} were given.`);
        return t(expandsto, match, { variables: ctx.variables, args: [ctx.args, cmdargs] });
      } else return {
        'type': 'node',
        'nonterminal': 'block',
        'production': 'othercmd',
        'children': (0, _jsItertools.chain)([[othercmd, optstar], m([optargs, args], match, ctx)])
      };
    },

    "def": (tree, match, { variables }) => {
      const [def, othercmd, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      variables.set(cmd, [0, _jsGrammar.ast.materialize(blocks)]);
      return empty;
    },

    "newcommand": (tree, match, ctx) => {
      const [newcommand, cmddef] = tree.children;
      return t(cmddef, match, ctx);
    },

    "{blocks}": (tree, match, ctx) => {
      const [_open, blocks, _close] = tree.children;
      return {
        "type": "node",
        "nonterminal": "block",
        "production": "{blocks}",
        "children": (0, _jsItertools.chain)([[_open], m([blocks], match, ctx), [_close]])
      };
    },

    "[blocks]": (tree, match, ctx) => {
      const [_open, blocks, _close] = tree.children;
      return {
        "type": "node",
        "nonterminal": "block",
        "production": "{blocks}",
        "children": (0, _jsItertools.chain)([[_open], m([blocks], match, ctx), [_close]])
      };
    },

    "*": tree => tree,

    "arg": (tree, match, { args, variables }) => {
      const [arg] = tree.children;
      const i = parseInt(arg.buffer.substr(1), 10) - 1; // #arg
      if (i >= args[1].length) throw new Error(`Requesting ${arg} but only got ${args[1].length} arguments.`);
      const subtree = args[1][i]; // arg
      return t(subtree, match, { args: args[0], variables });
    }

  },

  "endif": {

    "elsefi": (tree, match, ctx) => {
      const [_else, blocks, _fi] = tree.children;
      return {
        "type": "node",
        "nonterminal": "endif",
        "production": "fi",
        "children": (0, _jsItertools.chain)([[_else], m([blocks], match, ctx), [_fi]])
      };
    },

    "fi": () => ({
      "type": "leaf",
      "terminal": "text",
      "buffer": '\\fi'
    })

  },

  "cmddef": {

    "{cmd}[x]{blocks}": (tree, _, { variables }) => {
      const [_0, othercmd, _1, cmddefargs, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      let nargs = 0;
      if (cmddefargs.production === 'yes') {
        const [_4, text, _5] = cmddefargs.children;
        nargs = parseInt(text.buffer, 10);
      }
      variables.set(cmd, [nargs, blocks]);
      return empty;
    },

    "cmd[x]{blocks}": (tree, _, { variables }) => {
      const [othercmd, cmddefargs, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      let nargs = 0;
      if (cmddefargs.production === 'yes') {
        const [_4, text, _5] = cmddefargs.children;
        nargs = parseInt(text.buffer, 10);
      }
      variables.set(cmd, [nargs, blocks]);
      return empty;
    },

    "*cmd[x]{blocks}": (tree, _, { variables }) => {
      // do not know what to do with '*' at the moment
      const [_1, othercmd, cmddefargs, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      let nargs = 0;
      if (cmddefargs.production === 'yes') {
        const [_4, text, _5] = cmddefargs.children;
        nargs = parseInt(text.buffer, 10);
      }
      variables.set(cmd, [nargs, blocks]);
      return empty;
    }

  },

  "cmddefargs": {
    "yes": err("cmddefargs", "yes"),
    "no": err("cmddefargs", "no")
  },

  "cmd*": {
    "yes": err("cmd*", "yes"),
    "no": err("cmd*", "no")
  },

  "cmdoptargs": {
    "yes": (tree, match, ctx) => shake['block']['[blocks]'](tree, match, ctx),
    "no": () => empty
  },

  "cmdargs": {
    "add": (tree, match, ctx) => {
      const [_open, blocks, _close, tail] = tree.children;
      return {
        "type": "node",
        "nonterminal": "block",
        "production": "{blocks}",
        "children": (0, _jsItertools.chain)([[_open], m([blocks], match, ctx), [_close], m([tail], match, ctx)])
      };
    },
    "end": () => empty
  }

};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zaGFrZS5qcyJdLCJuYW1lcyI6WyJlbXB0eSIsImVyciIsIm5vbnRlcm1pbmFsIiwicHJvZHVjdGlvbiIsIkVycm9yIiwidCIsInRyYW5zZm9ybSIsIm0iLCJjaGlsZHJlbiIsIm1hdGNoIiwiY3R4IiwiY21hcCIsImNoaWxkIiwic2hha2UiLCJ0cmVlIiwiaWZjbWQiLCJibG9jazEiLCJlbmRpZiIsInZhcmlhYmxlIiwiYnVmZmVyIiwic3Vic3RyIiwidmFyaWFibGVzIiwiaGFzIiwiZmxhZyIsImdldCIsIl9lbHNlIiwiYmxvY2syIiwiX2ZpIiwiXyIsImZhbHNlY21kIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwic2V0IiwidHJ1ZWNtZCIsIm90aGVyY21kIiwib3B0c3RhciIsIm9wdGFyZ3MiLCJhcmdzIiwiY21kIiwiaGFzb3B0YXJncyIsImNtZGFyZ3MiLCJhcmdfaSIsIl9vcGVuIiwiYXJnIiwiX2Nsb3NlIiwiYXJnc3RhaWwiLCJwdXNoIiwibmFyZ3MiLCJleHBhbmRzdG8iLCJkZWYiLCJfMiIsImJsb2NrcyIsIl8zIiwibWF0ZXJpYWxpemUiLCJuZXdjb21tYW5kIiwiY21kZGVmIiwiaSIsInBhcnNlSW50Iiwic3VidHJlZSIsIl8wIiwiXzEiLCJjbWRkZWZhcmdzIiwiXzQiLCJ0ZXh0IiwiXzUiLCJ0YWlsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUEsTUFBTUEsUUFBUTtBQUNaLFVBQVMsTUFERztBQUVaLGlCQUFnQixPQUZKO0FBR1osZ0JBQWUsTUFISDtBQUlaLGNBQWE7QUFKRCxDQUFkOztBQU9BLE1BQU1DLE1BQU0sQ0FBRUMsV0FBRixFQUFnQkMsVUFBaEIsS0FBZ0MsTUFBTTtBQUNoRCxRQUFNLElBQUlDLEtBQUosQ0FBVyxHQUFFRixXQUFZLElBQUdDLFVBQVcsa0NBQXZDLENBQU47QUFDRCxDQUZEOztBQUlBLE1BQU1FLElBQUksZUFBSUMsU0FBZDtBQUNBLE1BQU1DLElBQUksQ0FBRUMsUUFBRixF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V0FBUSxNQUFNVjtBQVZMOztBQXJOUSxDQUFkIiwiZmlsZSI6InNoYWtlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2hhaW4gfSBmcm9tICdAYXVyZW9vbXMvanMtaXRlcnRvb2xzJyA7XG5pbXBvcnQgeyBhc3QgfSBmcm9tICdAYXVyZW9vbXMvanMtZ3JhbW1hcicgO1xuXG5jb25zdCBlbXB0eSA9IHtcbiAgJ3R5cGUnIDogJ25vZGUnICxcbiAgJ25vbnRlcm1pbmFsJyA6ICdlbXB0eScgLFxuICAncHJvZHVjdGlvbicgOiAnbWFpbicgLFxuICAnY2hpbGRyZW4nIDogW10gLFxufSA7XG5cbmNvbnN0IGVyciA9ICggbm9udGVybWluYWwgLCBwcm9kdWN0aW9uICkgPT4gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYCR7bm9udGVybWluYWx9LiR7cHJvZHVjdGlvbn0gc2hvdWxkIGhhdmUgYmVlbiBoYW5kbGVkIGJlZm9yZWApO1xufSA7XG5cbmNvbnN0IHQgPSBhc3QudHJhbnNmb3JtIDtcbmNvbnN0IG0gPSAoIGNoaWxkcmVuICwgbWF0Y2ggLCBjdHggKSA9PiBhc3QuY21hcCggY2hpbGQgPT4gdCggY2hpbGQgLCBtYXRjaCAsIGN0eCApICwgY2hpbGRyZW4gKSA7XG5cbmV4cG9ydCBjb25zdCBzaGFrZSA9IHtcblxuICBcImJsb2Nrc1wiIDoge1xuXG4gICAgXCJhZGRcIiA6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4gKHtcbiAgICAgIFwidHlwZVwiIDogXCJub2RlXCIgLFxuICAgICAgXCJub250ZXJtaW5hbFwiIDogXCJibG9ja3NcIiAsXG4gICAgICBcInByb2R1Y3Rpb25cIiA6IFwiYWRkXCIgLFxuICAgICAgXCJjaGlsZHJlblwiIDogbSggdHJlZS5jaGlsZHJlbiAsIG1hdGNoICwgY3R4ICkgLFxuICAgIH0pICxcblxuICAgIFwiZW5kXCIgOiAoKSA9PiBlbXB0eSAsXG5cbiAgfSAsXG5cbiAgXCJibG9ja1wiIDoge1xuXG4gICAgXCJ0ZXh0XCIgOiB0cmVlID0+IHRyZWUgLFxuXG4gICAgXCJuZXdpZlwiOiAoKSA9PiBlbXB0eSAsXG5cbiAgICBcImlmY21kXCI6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4ge1xuXG4gICAgICBjb25zdCBbIGlmY21kICwgYmxvY2sxICwgZW5kaWYgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSBpZmNtZC5idWZmZXIuc3Vic3RyKDMpO1xuXG4gICAgICBpZiAoY3R4LnZhcmlhYmxlcy5oYXModmFyaWFibGUpKSB7XG5cdGNvbnN0IGZsYWcgPSBjdHgudmFyaWFibGVzLmdldCh2YXJpYWJsZSk7XG5cdGlmIChmbGFnKSByZXR1cm4gdCggYmxvY2sxICwgbWF0Y2ggLCBjdHggKSA7XG5cdGVsc2UgaWYgKCBlbmRpZi5wcm9kdWN0aW9uID09PSBcImVsc2VmaVwiICkge1xuXHQgIGNvbnN0IFsgX2Vsc2UgLCBibG9jazIgLCBfZmkgXSA9IGVuZGlmLmNoaWxkcmVuIDtcblx0ICByZXR1cm4gdCggYmxvY2syICwgbWF0Y2ggLCBjdHggKSA7XG5cdH1cblx0ZWxzZSByZXR1cm4gZW1wdHkgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuXHQndHlwZScgOiAnbm9kZScgLFxuXHQnbm9udGVybWluYWwnIDogJ2Jsb2NrJyAsXG5cdCdwcm9kdWN0aW9uJyA6ICdpZmNtZCcgLFxuXHQnY2hpbGRyZW4nIDogY2hhaW4oIFsgWyBpZmNtZCBdICwgbSggW2Jsb2NrMSwgZW5kaWZdICwgbWF0Y2ggLCBjdHggKSBdICkgLFxuICAgICAgfSA7XG5cbiAgICB9ICxcblxuICAgIFwiZmFsc2VjbWRcIiA6ICggdHJlZSAsIF8gLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIGZhbHNlY21kIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZhbHNlY21kLmJ1ZmZlcjtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gYnVmZmVyLnN1YnN0cmluZygxLCBidWZmZXIubGVuZ3RoLTUpO1xuICAgICAgY3R4LnZhcmlhYmxlcy5zZXQodmFyaWFibGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9ICxcblxuICAgIFwidHJ1ZWNtZFwiIDogKCB0cmVlICwgXyAsIGN0eCApID0+IHtcbiAgICAgIGNvbnN0IFsgdHJ1ZWNtZCBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICBjb25zdCBidWZmZXIgPSB0cnVlY21kLmJ1ZmZlcjtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gYnVmZmVyLnN1YnN0cmluZygxLCBidWZmZXIubGVuZ3RoLTQpO1xuICAgICAgY3R4LnZhcmlhYmxlcy5zZXQodmFyaWFibGUsIHRydWUpO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0gLFxuXG4gICAgXCJjb21tZW50XCI6ICggKSA9PiAoe1xuICAgICAgJ3R5cGUnIDogJ2xlYWYnICxcbiAgICAgICd0ZXJtaW5hbCcgOiAnY29tbWVudCcgLFxuICAgICAgJ2J1ZmZlcicgOiAnJScgLFxuICAgIH0pICxcblxuICAgIFwib3RoZXJjbWRcIjogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIG90aGVyY21kICwgb3B0c3RhciAsIG9wdGFyZ3MgLCBhcmdzIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGxldCBjbWQgPSBvdGhlcmNtZC5idWZmZXI7XG4gICAgICBpZiAoIG9wdHN0YXIucHJvZHVjdGlvbiA9PT0gJ3llcycgKSBjbWQgKz0gJyonO1xuICAgICAgY29uc3QgaGFzb3B0YXJncyA9IG9wdGFyZ3MucHJvZHVjdGlvbiA9PT0gJ3llcycgO1xuICAgICAgY29uc3QgY21kYXJncyA9IFtdO1xuICAgICAgbGV0IGFyZ19pID0gYXJnc1xuICAgICAgd2hpbGUgKCBhcmdfaS5wcm9kdWN0aW9uID09PSAnYWRkJyApIHtcblx0Y29uc3QgWyBfb3BlbiAsIGFyZyAsIF9jbG9zZSAsIGFyZ3N0YWlsIF0gPSBhcmdfaS5jaGlsZHJlbiA7XG5cdGNtZGFyZ3MucHVzaChhcmcpIDtcblx0YXJnX2kgPSBhcmdzdGFpbCA7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc29wdGFyZ3MgJiYgY3R4LnZhcmlhYmxlcy5oYXMoY21kKSkge1xuXHQvLyB0b28gaGFyZCB0byBwYXJzZSBvcHQgYXJncyBjdXJyZW50bHlcblx0Y29uc3QgWyBuYXJncyAsIGV4cGFuZHN0byBdID0gY3R4LnZhcmlhYmxlcy5nZXQoY21kKSA7XG5cdGlmIChjbWRhcmdzLmxlbmd0aCAhPT0gbmFyZ3MpIHRocm93IG5ldyBFcnJvcihgQ29tbWFuZCAke2NtZH0gaXMgZGVmaW5lZCB3aXRoICR7bmFyZ3N9IGFyZ3VtZW50cyBidXQgJHtjbWRhcmdzLmxlbmd0aH0gd2VyZSBnaXZlbi5gKSA7XG5cdHJldHVybiB0KCBleHBhbmRzdG8gLCBtYXRjaCAsIHsgdmFyaWFibGVzOiBjdHgudmFyaWFibGVzICwgYXJnczogWyBjdHguYXJncyAsIGNtZGFyZ3MgXSB9ICkgO1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4ge1xuXHQndHlwZScgOiAnbm9kZScgLFxuXHQnbm9udGVybWluYWwnIDogJ2Jsb2NrJyAsXG5cdCdwcm9kdWN0aW9uJyA6ICdvdGhlcmNtZCcgLFxuXHQnY2hpbGRyZW4nIDogY2hhaW4oIFsgWyBvdGhlcmNtZCAsIG9wdHN0YXIgXSAsIG0oW29wdGFyZ3MsIGFyZ3NdLCBtYXRjaCwgY3R4KSBdICkgLFxuICAgICAgfSA7XG4gICAgfSAsXG5cbiAgICBcImRlZlwiOiAoIHRyZWUgLCBtYXRjaCAsIHsgdmFyaWFibGVzIH0gKSA9PiB7XG4gICAgICBjb25zdCBbIGRlZiAsIG90aGVyY21kICwgXzIgLCBibG9ja3MgLCBfMyBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICBjb25zdCBjbWQgPSBvdGhlcmNtZC5idWZmZXI7XG4gICAgICB2YXJpYWJsZXMuc2V0KGNtZCwgWzAsIGFzdC5tYXRlcmlhbGl6ZShibG9ja3MpXSk7XG4gICAgICByZXR1cm4gZW1wdHkgO1xuICAgIH0gLFxuXG4gICAgXCJuZXdjb21tYW5kXCI6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4ge1xuICAgICAgY29uc3QgWyBuZXdjb21tYW5kICwgY21kZGVmIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIHJldHVybiB0KCBjbWRkZWYgLCBtYXRjaCAsIGN0eCApIDtcbiAgICB9ICxcblxuICAgIFwie2Jsb2Nrc31cIjogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIF9vcGVuICwgYmxvY2tzICwgX2Nsb3NlIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIHJldHVybiB7XG5cdFwidHlwZVwiIDogXCJub2RlXCIgLFxuXHRcIm5vbnRlcm1pbmFsXCIgOiBcImJsb2NrXCIgLFxuXHRcInByb2R1Y3Rpb25cIiA6IFwie2Jsb2Nrc31cIiAsXG5cdFwiY2hpbGRyZW5cIiA6IGNoYWluKCBbIFsgX29wZW4gXSAsIG0oIFsgYmxvY2tzIF0gLCBtYXRjaCAsIGN0eCApICwgWyBfY2xvc2UgXSBdICkgLFxuICAgICAgfSA7XG4gICAgfSAsXG5cbiAgICBcIltibG9ja3NdXCI6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4ge1xuICAgICAgY29uc3QgWyBfb3BlbiAsIGJsb2NrcyAsIF9jbG9zZSBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICByZXR1cm4ge1xuXHRcInR5cGVcIiA6IFwibm9kZVwiICxcblx0XCJub250ZXJtaW5hbFwiIDogXCJibG9ja1wiICxcblx0XCJwcm9kdWN0aW9uXCIgOiBcIntibG9ja3N9XCIgLFxuXHRcImNoaWxkcmVuXCIgOiBjaGFpbiggWyBbIF9vcGVuIF0gLCBtKCBbIGJsb2NrcyBdICwgbWF0Y2ggLCBjdHggKSAsIFsgX2Nsb3NlIF0gXSApICxcbiAgICAgIH0gO1xuICAgIH0gLFxuXG4gICAgXCIqXCIgOiB0cmVlID0+IHRyZWUgLFxuXG4gICAgXCJhcmdcIjogKCB0cmVlICwgbWF0Y2ggLCB7IGFyZ3MgLCB2YXJpYWJsZXMgfSApID0+IHtcbiAgICAgIGNvbnN0IFsgYXJnIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGNvbnN0IGkgPSBwYXJzZUludChhcmcuYnVmZmVyLnN1YnN0cigxKSwgMTApIC0gMTsgLy8gI2FyZ1xuICAgICAgaWYgKCBpID49IGFyZ3NbMV0ubGVuZ3RoICkgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0aW5nICR7YXJnfSBidXQgb25seSBnb3QgJHthcmdzWzFdLmxlbmd0aH0gYXJndW1lbnRzLmApIDtcbiAgICAgIGNvbnN0IHN1YnRyZWUgPSBhcmdzWzFdW2ldIC8vIGFyZ1xuICAgICAgcmV0dXJuIHQoIHN1YnRyZWUgLCBtYXRjaCAsIHsgYXJnczogYXJnc1swXSAsIHZhcmlhYmxlcyB9ICkgO1xuICAgIH0gLFxuXG4gIH0gLFxuXG4gIFwiZW5kaWZcIjoge1xuXG4gICAgXCJlbHNlZmlcIiA6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4ge1xuICAgICAgY29uc3QgWyBfZWxzZSAsIGJsb2NrcyAsIF9maSBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICByZXR1cm4ge1xuXHRcInR5cGVcIiA6IFwibm9kZVwiICxcblx0XCJub250ZXJtaW5hbFwiIDogXCJlbmRpZlwiICxcblx0XCJwcm9kdWN0aW9uXCIgOiBcImZpXCIgLFxuXHRcImNoaWxkcmVuXCIgOiBjaGFpbihbIFsgX2Vsc2UgXSAsIG0oIFsgYmxvY2tzIF0gLCBtYXRjaCAsIGN0eCApICwgWyBfZmkgXSBdICkgLFxuICAgICAgfSA7XG4gICAgfSAsXG5cbiAgICBcImZpXCIgOiAoICkgPT4gKHtcbiAgICAgIFwidHlwZVwiIDogXCJsZWFmXCIgLFxuICAgICAgXCJ0ZXJtaW5hbFwiIDogXCJ0ZXh0XCIgLFxuICAgICAgXCJidWZmZXJcIiA6ICdcXFxcZmknICxcbiAgICB9KSAsXG5cbiAgfSAsXG5cbiAgXCJjbWRkZWZcIiA6IHtcblxuICAgIFwie2NtZH1beF17YmxvY2tzfVwiOiAoIHRyZWUgLCBfICwgeyB2YXJpYWJsZXMgfSApID0+IHtcbiAgICAgIGNvbnN0IFsgXzAgLCBvdGhlcmNtZCAsIF8xICwgY21kZGVmYXJncyAsIF8yICwgYmxvY2tzICwgXzMgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgY29uc3QgY21kID0gb3RoZXJjbWQuYnVmZmVyO1xuICAgICAgbGV0IG5hcmdzID0gMDtcbiAgICAgIGlmIChjbWRkZWZhcmdzLnByb2R1Y3Rpb24gPT09ICd5ZXMnKSB7XG5cdGNvbnN0IFsgXzQgLCB0ZXh0ICwgXzUgXSA9IGNtZGRlZmFyZ3MuY2hpbGRyZW4gO1xuXHRuYXJncyA9IHBhcnNlSW50KHRleHQuYnVmZmVyLCAxMCk7XG4gICAgICB9XG4gICAgICB2YXJpYWJsZXMuc2V0KGNtZCwgWyBuYXJncyAsIGJsb2NrcyBdKTtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9ICxcblxuICAgIFwiY21kW3hde2Jsb2Nrc31cIjogKCB0cmVlICwgXyAsIHsgdmFyaWFibGVzIH0gKSA9PiB7XG4gICAgICBjb25zdCBbIG90aGVyY21kICwgY21kZGVmYXJncyAsIF8yICwgYmxvY2tzICwgXzMgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgY29uc3QgY21kID0gb3RoZXJjbWQuYnVmZmVyO1xuICAgICAgbGV0IG5hcmdzID0gMDtcbiAgICAgIGlmIChjbWRkZWZhcmdzLnByb2R1Y3Rpb24gPT09ICd5ZXMnKSB7XG5cdGNvbnN0IFsgXzQgLCB0ZXh0ICwgXzUgXSA9IGNtZGRlZmFyZ3MuY2hpbGRyZW4gO1xuXHRuYXJncyA9IHBhcnNlSW50KHRleHQuYnVmZmVyLCAxMCk7XG4gICAgICB9XG4gICAgICB2YXJpYWJsZXMuc2V0KGNtZCwgWyBuYXJncyAsIGJsb2NrcyBdKTtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9ICxcblxuICAgIFwiKmNtZFt4XXtibG9ja3N9XCI6ICggdHJlZSAsIF8gLCB7IHZhcmlhYmxlcyB9ICkgPT4ge1xuICAgICAgLy8gZG8gbm90IGtub3cgd2hhdCB0byBkbyB3aXRoICcqJyBhdCB0aGUgbW9tZW50XG4gICAgICBjb25zdCBbIF8xICwgb3RoZXJjbWQgLCBjbWRkZWZhcmdzICwgXzIgLCBibG9ja3MgLCBfMyBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICBjb25zdCBjbWQgPSBvdGhlcmNtZC5idWZmZXI7XG4gICAgICBsZXQgbmFyZ3MgPSAwO1xuICAgICAgaWYgKGNtZGRlZmFyZ3MucHJvZHVjdGlvbiA9PT0gJ3llcycpIHtcblx0Y29uc3QgWyBfNCAsIHRleHQgLCBfNSBdID0gY21kZGVmYXJncy5jaGlsZHJlbiA7XG5cdG5hcmdzID0gcGFyc2VJbnQodGV4dC5idWZmZXIsIDEwKTtcbiAgICAgIH1cbiAgICAgIHZhcmlhYmxlcy5zZXQoY21kLCBbIG5hcmdzICwgYmxvY2tzIF0pO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0gLFxuXG4gIH0gLFxuXG4gIFwiY21kZGVmYXJnc1wiOiB7XG4gICAgXCJ5ZXNcIiA6IGVyciggXCJjbWRkZWZhcmdzXCIgLCBcInllc1wiICkgLFxuICAgIFwibm9cIiA6IGVyciggXCJjbWRkZWZhcmdzXCIgLCBcIm5vXCIgKSAsXG4gIH0gLFxuXG4gIFwiY21kKlwiOiB7XG4gICAgXCJ5ZXNcIiA6IGVyciggXCJjbWQqXCIgLCBcInllc1wiICkgLFxuICAgIFwibm9cIiA6IGVyciggXCJjbWQqXCIgLCBcIm5vXCIgKSAsXG4gIH0gLFxuXG4gIFwiY21kb3B0YXJnc1wiOiB7XG4gICAgXCJ5ZXNcIiA6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4gc2hha2VbJ2Jsb2NrJ11bJ1tibG9ja3NdJ10oIHRyZWUgLCBtYXRjaCAsIGN0eCApLFxuICAgIFwibm9cIiA6ICgpID0+IGVtcHR5ICxcbiAgfSAsXG5cbiAgXCJjbWRhcmdzXCI6IHtcbiAgICBcImFkZFwiIDogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIF9vcGVuICwgYmxvY2tzICwgX2Nsb3NlICwgdGFpbCBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICByZXR1cm4ge1xuXHRcInR5cGVcIiA6IFwibm9kZVwiICxcblx0XCJub250ZXJtaW5hbFwiIDogXCJibG9ja1wiICxcblx0XCJwcm9kdWN0aW9uXCIgOiBcIntibG9ja3N9XCIgLFxuXHRcImNoaWxkcmVuXCIgOiBjaGFpbiggWyBbIF9vcGVuIF0gLCBtKCBbIGJsb2NrcyBdICwgbWF0Y2ggLCBjdHggKSAsIFsgX2Nsb3NlIF0gLCBtKCBbIHRhaWwgXSAsIG1hdGNoICwgY3R4ICkgXSApICxcbiAgICAgIH0gO1xuICAgIH0gLFxuICAgIFwiZW5kXCIgOiAoKSA9PiBlbXB0eSAsXG4gIH0gLFxuXG59IDtcbiJdfQ==