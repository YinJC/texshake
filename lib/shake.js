'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shake = undefined;

var _jsItertools = require('@aureooms/js-itertools');

var _jsGrammar = require('@aureooms/js-grammar');

const empty = {
  'type': 'node',
  'nonterminal': 'empty',
  'production': 'main',
  'children': []
};

const err = (nonterminal, production) => () => {
  throw new Error(`${nonterminal}.${production} should have been handled before`);
};

const t = _jsGrammar.ast.transform;
const m = (children, match, ctx) => _jsGrammar.ast.cmap(child => t(child, match, ctx), children);

const shake = exports.shake = {

  "blocks": {

    "add": (tree, match, ctx) => ({
      "type": "node",
      "nonterminal": "blocks",
      "production": "add",
      "children": m(tree.children, match, ctx)
    }),

    "end": () => empty

  },

  "block": {

    "text": tree => tree,

    "newif": () => empty,

    "ifcmd": (tree, match, ctx) => {

      const [ifcmd, block1, endif] = tree.children;
      const variable = ifcmd.buffer.substr(3);

      if (ctx.variables.has(variable)) {
        const flag = ctx.variables.get(variable);
        if (flag) return t(ctx, block1, match);else if (endif.production === "elsefi") {
          const [_else, block2, _fi] = endif.children;
          return t(ctx, block2, match);
        } else return empty;
      }

      return {
        'type': 'node',
        'nonterminal': 'block',
        'production': 'ifcmd',
        'children': (0, _jsItertools.chain)([[ifcmd], m([block1, endif], match, ctx)])
      };
    },

    "falsecmd": (tree, _, ctx) => {
      const [falsecmd] = tree.children;
      const buffer = falsecmd.buffer;
      const variable = buffer.substring(1, buffer.length - 5);
      ctx.variables.set(variable, false);
      return empty;
    },

    "truecmd": (tree, _, ctx) => {
      const [truecmd] = tree.children;
      const buffer = truecmd.buffer;
      const variable = buffer.substring(1, buffer.length - 4);
      ctx.variables.set(variable, true);
      return empty;
    },

    "comment": () => ({
      'type': 'leaf',
      'terminal': 'comment',
      'buffer': '%'
    }),

    "othercmd": (tree, match, ctx) => {
      const [othercmd, optstar, optargs, args] = tree.children;
      const cmd = othercmd.buffer;
      if (optstar.production === 'yes') cmd += '*';
      const hasoptargs = optargs.production === 'yes';
      const cmdargs = [];
      let arg_i = args;
      while (arg_i.production === 'add') {
        const [_open, arg, _close, argstail] = arg_i.children;
        cmdargs.push(arg);
        arg_i = argstail;
      }
      if (!hasoptargs && ctx.variables.has(cmd)) {
        // too hard to parse opt args currently
        const [nargs, expandsto] = ctx.variables.get(cmd);
        if (cmdargs.length !== nargs) throw new Error(`Command ${cmd} is defined with ${nargs} arguments but ${cmdargs.length} were given.`);
        return t(expandsto, match, { variables: ctx.variables, args: [ctx.args, cmdargs] });
      } else return {
        'type': 'node',
        'nonterminal': 'block',
        'production': 'othercmd',
        'children': (0, _jsItertools.chain)([[othercmd, optstar], m([optargs, args], match, ctx)])
      };
    },

    "def": (tree, match, { variables }) => {
      const [def, othercmd, _2, blocks, _3] = tree.children;
      cmd = othercmd.buffer;
      variables.set(cmd, [0, _jsGrammar.ast.materialize(blocks)]);
      return empty;
    },

    "newcommand": (tree, match, ctx) => {
      const [newcommand, cmddef] = tree.children;
      return t(cmddef, match, ctx);
    },

    "{blocks}": (tree, match, ctx) => {
      const [_open, blocks, _close] = tree.children;
      return {
        "type": "node",
        "nonterminal": "block",
        "production": "{blocks}",
        "children": (0, _jsItertools.chain)([[_open], m([blocks], match, ctx), [_close]])
      };
    },

    "[blocks]": (tree, match, ctx) => {
      const [_open, blocks, _close] = tree.children;
      return {
        "type": "node",
        "nonterminal": "block",
        "production": "{blocks}",
        "children": (0, _jsItertools.chain)([[_open], m([blocks], match, ctx), [_close]])
      };
    },

    "*": tree => tree,

    "arg": (tree, match, { args, variables }) => {
      const [arg] = tree.children;
      const i = parseInt(arg.buffer.substr(1), 10) - 1; // #arg
      if (i >= args[1].length) throw new Error(`Requesting ${arg} but only got ${args[1].length} arguments.`);
      const subtree = args[1][i]; // arg
      return t(subtree, match, { args: args[0], variables });
    }

  },

  "endif": {

    "elsefi": (tree, match, ctx) => {
      const [_else, blocks, _fi] = tree.children;
      return {
        "type": "node",
        "nonterminal": "endif",
        "production": "fi",
        "children": (0, _jsItertools.chain)([[_else], m([blocks], match, ctx), [_fi]])
      };
    },

    "fi": () => ({
      "type": "leaf",
      "terminal": "text",
      "buffer": '\\fi'
    })

  },

  "cmddef": {

    "{cmd}[x]{blocks}": (tree, _, { variables }) => {
      const [_0, othercmd, _1, cmddefargs, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      let nargs = 0;
      if (cmddefargs.production === 'yes') {
        const [_4, text, _5] = cmddefargs.children;
        nargs = parseInt(text.buffer, 10);
      }
      variables.set(cmd, [nargs, blocks]);
      return empty;
    },

    "cmd[x]{blocks}": (tree, _, { variables }) => {
      const [othercmd, cmddefargs, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      let nargs = 0;
      if (cmddefargs.production === 'yes') {
        const [_4, text, _5] = cmddefargs.children;
        nargs = parseInt(text.buffer, 10);
      }
      variables.set(cmd, [nargs, blocks]);
      return empty;
    },

    "*cmd[x]{blocks}": (tree, _, { variables }) => {
      // do not know what to do with '*' at the moment
      const [_1, othercmd, cmddefargs, _2, blocks, _3] = tree.children;
      const cmd = othercmd.buffer;
      let nargs = 0;
      if (cmddefargs.production === 'yes') {
        const [_4, text, _5] = cmddefargs.children;
        nargs = parseInt(text.buffer, 10);
      }
      variables.set(cmd, [nargs, blocks]);
      return empty;
    }

  },

  "cmddefargs": {
    "yes": err("cmddefargs", "yes"),
    "no": err("cmddefargs", "no")
  },

  "cmd*": {
    "yes": err("cmd*", "yes"),
    "no": err("cmd*", "no")
  },

  "cmdoptargs": {
    "yes": err("cmdoptargs", "yes"),
    "no": err("cmdoptargs", "no")
  },

  "cmdargs": {
    "add": err("cmdargs", "yes"),
    "end": err("cmdargs", "no")
  }

};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zaGFrZS5qcyJdLCJuYW1lcyI6WyJlbXB0eSIsImVyciIsIm5vbnRlcm1pbmFsIiwicHJvZHVjdGlvbiIsIkVycm9yIiwidCIsInRyYW5zZm9ybSIsIm0iLCJjaGlsZHJlbiIsIm1hdGNoIiwiY3R4IiwiY21hcCIsImNoaWxkIiwic2hha2UiLCJ0cmVlIiwiaWZjbWQiLCJibG9jazEiLCJlbmRpZiIsInZhcmlhYmxlIiwiYnVmZmVyIiwic3Vic3RyIiwidmFyaWFibGVzIiwiaGFzIiwiZmxhZyIsImdldCIsIl9lbHNlIiwiYmxvY2syIiwiX2ZpIiwiXyIsImZhbHNlY21kIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwic2V0IiwidHJ1ZWNtZCIsIm90aGVyY21kIiwib3B0c3RhciIsIm9wdGFyZ3MiLCJhcmdzIiwiY21kIiwiaGFzb3B0YXJncyIsImNtZGFyZ3MiLCJhcmdfaSIsIl9vcGVuIiwiYXJnIiwiX2Nsb3NlIiwiYXJnc3RhaWwiLCJwdXNoIiwibmFyZ3MiLCJleHBhbmRzdG8iLCJkZWYiLCJfMiIsImJsb2NrcyIsIl8zIiwibWF0ZXJpYWxpemUiLCJuZXdjb21tYW5kIiwiY21kZGVmIiwiaSIsInBhcnNlSW50Iiwic3VidHJlZSIsIl8wIiwiXzEiLCJjbWRkZWZhcmdzIiwiXzQiLCJ0ZXh0IiwiXzUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQSxNQUFNQSxRQUFRO0FBQ1osVUFBUyxNQURHO0FBRVosaUJBQWdCLE9BRko7QUFHWixnQkFBZSxNQUhIO0FBSVosY0FBYTtBQUpELENBQWQ7O0FBT0EsTUFBTUMsTUFBTSxDQUFFQyxXQUFGLEVBQWdCQyxVQUFoQixLQUFnQyxNQUFNO0FBQ2hELFFBQU0sSUFBSUMsS0FBSixDQUFXLEdBQUVGLFdBQVksSUFBR0MsVUFBVyxrQ0FBdkMsQ0FBTjtBQUNELENBRkQ7O0FBSUEsTUFBTUUsSUFBSSxlQUFJQyxTQUFkO0FBQ0EsTUFBTUMsSUFBSSxDQUFFQyxRQUFGLEVBQWFDLEtB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QWQsRUFBc0IsRUFBdEIsQ0FBUjtBQUNNO0FBQ0RFLGdCQUFVVyxHQUFWLENBQWNNLEdBQWQsRUFBbUIsQ0FBRVMsS0FBRixFQUFVSSxNQUFWLENBQW5CO0FBQ0EsYUFBT25ELEtBQVA7QUFDRDs7QUFyQ1EsR0E1SlE7O0FBcU1uQixnQkFBYztBQUNaLFdBQVFDLElBQUssWUFBTCxFQUFvQixLQUFwQixDQURJO0FBRVosVUFBT0EsSUFBSyxZQUFMLEVBQW9CLElBQXBCO0FBRkssR0FyTUs7O0FBME1uQixVQUFRO0FBQ04sV0FBUUEsSUFBSyxNQUFMLEVBQWMsS0FBZCxDQURGO0FBRU4sVUFBT0EsSUFBSyxNQUFMLEVBQWMsSUFBZDtBQUZELEdBMU1XOztBQStNbkIsZ0JBQWM7QUFDWixXQUFRQSxJQUFLLFlBQUwsRUFBb0IsS0FBcEIsQ0FESTtBQUVaLFVBQU9BLElBQUssWUFBTCxFQUFvQixJQUFwQjtBQUZLLEdBL01LOztBQW9ObkIsYUFBVztBQUNULFdBQVFBLElBQUssU0FBTCxFQUFpQixLQUFqQixDQURDO0FBRVQsV0FBUUEsSUFBSyxTQUFMLEVBQWlCLElBQWpCO0FBRkM7O0FBcE5RLENBQWQiLCJmaWxlIjoic2hha2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBuZXh0ICwgY2hhaW4gfSBmcm9tICdAYXVyZW9vbXMvanMtaXRlcnRvb2xzJyA7XG5pbXBvcnQgeyBhc3QgfSBmcm9tICdAYXVyZW9vbXMvanMtZ3JhbW1hcicgO1xuXG5jb25zdCBlbXB0eSA9IHtcbiAgJ3R5cGUnIDogJ25vZGUnICxcbiAgJ25vbnRlcm1pbmFsJyA6ICdlbXB0eScgLFxuICAncHJvZHVjdGlvbicgOiAnbWFpbicgLFxuICAnY2hpbGRyZW4nIDogW10gLFxufSA7XG5cbmNvbnN0IGVyciA9ICggbm9udGVybWluYWwgLCBwcm9kdWN0aW9uICkgPT4gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYCR7bm9udGVybWluYWx9LiR7cHJvZHVjdGlvbn0gc2hvdWxkIGhhdmUgYmVlbiBoYW5kbGVkIGJlZm9yZWApO1xufSA7XG5cbmNvbnN0IHQgPSBhc3QudHJhbnNmb3JtIDtcbmNvbnN0IG0gPSAoIGNoaWxkcmVuICwgbWF0Y2ggLCBjdHggKSA9PiBhc3QuY21hcCggY2hpbGQgPT4gdCggY2hpbGQgLCBtYXRjaCAsIGN0eCApICwgY2hpbGRyZW4gKSA7XG5cbmV4cG9ydCBjb25zdCBzaGFrZSA9IHtcblxuICBcImJsb2Nrc1wiIDoge1xuXG4gICAgXCJhZGRcIiA6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4gKHtcbiAgICAgIFwidHlwZVwiIDogXCJub2RlXCIgLFxuICAgICAgXCJub250ZXJtaW5hbFwiIDogXCJibG9ja3NcIiAsXG4gICAgICBcInByb2R1Y3Rpb25cIiA6IFwiYWRkXCIgLFxuICAgICAgXCJjaGlsZHJlblwiIDogbSggdHJlZS5jaGlsZHJlbiAsIG1hdGNoICwgY3R4ICkgLFxuICAgIH0pICxcblxuICAgIFwiZW5kXCIgOiAoKSA9PiBlbXB0eSAsXG5cbiAgfSAsXG5cbiAgXCJibG9ja1wiIDoge1xuXG4gICAgXCJ0ZXh0XCIgOiB0cmVlID0+IHRyZWUgLFxuXG4gICAgXCJuZXdpZlwiOiAoKSA9PiBlbXB0eSAsXG5cbiAgICBcImlmY21kXCI6ICggdHJlZSAsIG1hdGNoICwgY3R4ICkgPT4ge1xuXG4gICAgICBjb25zdCBbIGlmY21kICwgYmxvY2sxICwgZW5kaWYgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgY29uc3QgdmFyaWFibGUgPSBpZmNtZC5idWZmZXIuc3Vic3RyKDMpO1xuXG4gICAgICBpZiAoY3R4LnZhcmlhYmxlcy5oYXModmFyaWFibGUpKSB7XG5cdGNvbnN0IGZsYWcgPSBjdHgudmFyaWFibGVzLmdldCh2YXJpYWJsZSk7XG5cdGlmIChmbGFnKSByZXR1cm4gdCggY3R4ICwgYmxvY2sxICwgbWF0Y2ggKSA7XG5cdGVsc2UgaWYgKCBlbmRpZi5wcm9kdWN0aW9uID09PSBcImVsc2VmaVwiICkge1xuXHQgIGNvbnN0IFsgX2Vsc2UgLCBibG9jazIgLCBfZmkgXSA9IGVuZGlmLmNoaWxkcmVuIDtcblx0ICByZXR1cm4gdCggY3R4ICwgYmxvY2syICwgbWF0Y2ggKSA7XG5cdH1cblx0ZWxzZSByZXR1cm4gZW1wdHkgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuXHQndHlwZScgOiAnbm9kZScgLFxuXHQnbm9udGVybWluYWwnIDogJ2Jsb2NrJyAsXG5cdCdwcm9kdWN0aW9uJyA6ICdpZmNtZCcgLFxuXHQnY2hpbGRyZW4nIDogY2hhaW4oIFsgWyBpZmNtZCBdICwgbSggW2Jsb2NrMSwgZW5kaWZdICwgbWF0Y2ggLCBjdHggKSBdICkgLFxuICAgICAgfSA7XG5cbiAgICB9ICxcblxuICAgIFwiZmFsc2VjbWRcIiA6ICggdHJlZSAsIF8gLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIGZhbHNlY21kIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGZhbHNlY21kLmJ1ZmZlcjtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gYnVmZmVyLnN1YnN0cmluZygxLCBidWZmZXIubGVuZ3RoLTUpO1xuICAgICAgY3R4LnZhcmlhYmxlcy5zZXQodmFyaWFibGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9ICxcblxuICAgIFwidHJ1ZWNtZFwiIDogKCB0cmVlICwgXyAsIGN0eCApID0+IHtcbiAgICAgIGNvbnN0IFsgdHJ1ZWNtZCBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICBjb25zdCBidWZmZXIgPSB0cnVlY21kLmJ1ZmZlcjtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gYnVmZmVyLnN1YnN0cmluZygxLCBidWZmZXIubGVuZ3RoLTQpO1xuICAgICAgY3R4LnZhcmlhYmxlcy5zZXQodmFyaWFibGUsIHRydWUpO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0gLFxuXG4gICAgXCJjb21tZW50XCI6ICggKSA9PiAoe1xuICAgICAgJ3R5cGUnIDogJ2xlYWYnICxcbiAgICAgICd0ZXJtaW5hbCcgOiAnY29tbWVudCcgLFxuICAgICAgJ2J1ZmZlcicgOiAnJScgLFxuICAgIH0pICxcblxuICAgIFwib3RoZXJjbWRcIjogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIG90aGVyY21kICwgb3B0c3RhciAsIG9wdGFyZ3MgLCBhcmdzIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGNvbnN0IGNtZCA9IG90aGVyY21kLmJ1ZmZlcjtcbiAgICAgIGlmICggb3B0c3Rhci5wcm9kdWN0aW9uID09PSAneWVzJyApIGNtZCArPSAnKic7XG4gICAgICBjb25zdCBoYXNvcHRhcmdzID0gb3B0YXJncy5wcm9kdWN0aW9uID09PSAneWVzJyA7XG4gICAgICBjb25zdCBjbWRhcmdzID0gW107XG4gICAgICBsZXQgYXJnX2kgPSBhcmdzXG4gICAgICB3aGlsZSAoIGFyZ19pLnByb2R1Y3Rpb24gPT09ICdhZGQnICkge1xuXHRjb25zdCBbIF9vcGVuICwgYXJnICwgX2Nsb3NlICwgYXJnc3RhaWwgXSA9IGFyZ19pLmNoaWxkcmVuIDtcblx0Y21kYXJncy5wdXNoKGFyZykgO1xuXHRhcmdfaSA9IGFyZ3N0YWlsIDtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzb3B0YXJncyAmJiBjdHgudmFyaWFibGVzLmhhcyhjbWQpKSB7IC8vIHRvbyBoYXJkIHRvIHBhcnNlIG9wdCBhcmdzIGN1cnJlbnRseVxuXHRjb25zdCBbIG5hcmdzICwgZXhwYW5kc3RvIF0gPSBjdHgudmFyaWFibGVzLmdldChjbWQpIDtcblx0aWYgKGNtZGFyZ3MubGVuZ3RoICE9PSBuYXJncykgdGhyb3cgbmV3IEVycm9yKGBDb21tYW5kICR7Y21kfSBpcyBkZWZpbmVkIHdpdGggJHtuYXJnc30gYXJndW1lbnRzIGJ1dCAke2NtZGFyZ3MubGVuZ3RofSB3ZXJlIGdpdmVuLmApIDtcblx0cmV0dXJuIHQoIGV4cGFuZHN0byAsIG1hdGNoICwgeyB2YXJpYWJsZXM6IGN0eC52YXJpYWJsZXMgLCBhcmdzOiBbIGN0eC5hcmdzICwgY21kYXJncyBdIH0gKSA7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB7XG5cdCd0eXBlJyA6ICdub2RlJyAsXG5cdCdub250ZXJtaW5hbCcgOiAnYmxvY2snICxcblx0J3Byb2R1Y3Rpb24nIDogJ290aGVyY21kJyAsXG5cdCdjaGlsZHJlbicgOiBjaGFpbiggWyBbIG90aGVyY21kICwgb3B0c3RhciBdICwgbShbb3B0YXJncywgYXJnc10sIG1hdGNoLCBjdHgpIF0gKSAsXG4gICAgICB9IDtcbiAgICB9ICxcblxuICAgIFwiZGVmXCI6ICggdHJlZSAsIG1hdGNoICwgeyB2YXJpYWJsZXMgfSApID0+IHtcbiAgICAgIGNvbnN0IFsgZGVmICwgb3RoZXJjbWQgLCBfMiAsIGJsb2NrcyAsIF8zIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGNtZCA9IG90aGVyY21kLmJ1ZmZlcjtcbiAgICAgIHZhcmlhYmxlcy5zZXQoY21kLCBbMCwgYXN0Lm1hdGVyaWFsaXplKGJsb2NrcyldKTtcbiAgICAgIHJldHVybiBlbXB0eSA7XG4gICAgfSAsXG5cbiAgICBcIm5ld2NvbW1hbmRcIjogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIG5ld2NvbW1hbmQgLCBjbWRkZWYgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgcmV0dXJuIHQoIGNtZGRlZiAsIG1hdGNoICwgY3R4ICkgO1xuICAgIH0gLFxuXG4gICAgXCJ7YmxvY2tzfVwiOiAoIHRyZWUgLCBtYXRjaCAsIGN0eCApID0+IHtcbiAgICAgIGNvbnN0IFsgX29wZW4gLCBibG9ja3MgLCBfY2xvc2UgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgcmV0dXJuIHtcblx0XCJ0eXBlXCIgOiBcIm5vZGVcIiAsXG5cdFwibm9udGVybWluYWxcIiA6IFwiYmxvY2tcIiAsXG5cdFwicHJvZHVjdGlvblwiIDogXCJ7YmxvY2tzfVwiICxcblx0XCJjaGlsZHJlblwiIDogY2hhaW4oIFsgWyBfb3BlbiBdICwgbSggWyBibG9ja3MgXSAsIG1hdGNoICwgY3R4ICkgLCBbIF9jbG9zZSBdIF0gKSAsXG4gICAgICB9IDtcbiAgICB9ICxcblxuICAgIFwiW2Jsb2Nrc11cIjogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIF9vcGVuICwgYmxvY2tzICwgX2Nsb3NlIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIHJldHVybiB7XG5cdFwidHlwZVwiIDogXCJub2RlXCIgLFxuXHRcIm5vbnRlcm1pbmFsXCIgOiBcImJsb2NrXCIgLFxuXHRcInByb2R1Y3Rpb25cIiA6IFwie2Jsb2Nrc31cIiAsXG5cdFwiY2hpbGRyZW5cIiA6IGNoYWluKCBbIFsgX29wZW4gXSAsIG0oIFsgYmxvY2tzIF0gLCBtYXRjaCAsIGN0eCApICwgWyBfY2xvc2UgXSBdICkgLFxuICAgICAgfSA7XG4gICAgfSAsXG5cbiAgICBcIipcIiA6IHRyZWUgPT4gdHJlZSAsXG5cbiAgICBcImFyZ1wiOiAoIHRyZWUgLCBtYXRjaCAsIHsgYXJncyAsIHZhcmlhYmxlcyB9ICkgPT4ge1xuICAgICAgY29uc3QgWyBhcmcgXSA9IHRyZWUuY2hpbGRyZW4gO1xuICAgICAgY29uc3QgaSA9IHBhcnNlSW50KGFyZy5idWZmZXIuc3Vic3RyKDEpLCAxMCkgLSAxOyAvLyAjYXJnXG4gICAgICBpZiAoIGkgPj0gYXJnc1sxXS5sZW5ndGggKSB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3RpbmcgJHthcmd9IGJ1dCBvbmx5IGdvdCAke2FyZ3NbMV0ubGVuZ3RofSBhcmd1bWVudHMuYCkgO1xuICAgICAgY29uc3Qgc3VidHJlZSA9IGFyZ3NbMV1baV0gLy8gYXJnXG4gICAgICByZXR1cm4gdCggc3VidHJlZSAsIG1hdGNoICwgeyBhcmdzOiBhcmdzWzBdICwgdmFyaWFibGVzIH0gKSA7XG4gICAgfSAsXG5cbiAgfSAsXG5cbiAgXCJlbmRpZlwiOiB7XG5cbiAgICBcImVsc2VmaVwiIDogKCB0cmVlICwgbWF0Y2ggLCBjdHggKSA9PiB7XG4gICAgICBjb25zdCBbIF9lbHNlICwgYmxvY2tzICwgX2ZpIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIHJldHVybiB7XG5cdFwidHlwZVwiIDogXCJub2RlXCIgLFxuXHRcIm5vbnRlcm1pbmFsXCIgOiBcImVuZGlmXCIgLFxuXHRcInByb2R1Y3Rpb25cIiA6IFwiZmlcIiAsXG5cdFwiY2hpbGRyZW5cIiA6IGNoYWluKFsgWyBfZWxzZSBdICwgbSggWyBibG9ja3MgXSAsIG1hdGNoICwgY3R4ICkgLCBbIF9maSBdIF0gKSAsXG4gICAgICB9IDtcbiAgICB9ICxcblxuICAgIFwiZmlcIiA6ICggKSA9PiAoe1xuICAgICAgXCJ0eXBlXCIgOiBcImxlYWZcIiAsXG4gICAgICBcInRlcm1pbmFsXCIgOiBcInRleHRcIiAsXG4gICAgICBcImJ1ZmZlclwiIDogJ1xcXFxmaScgLFxuICAgIH0pICxcblxuICB9ICxcblxuICBcImNtZGRlZlwiIDoge1xuXG4gICAgXCJ7Y21kfVt4XXtibG9ja3N9XCI6ICggdHJlZSAsIF8gLCB7IHZhcmlhYmxlcyB9ICkgPT4ge1xuICAgICAgY29uc3QgWyBfMCAsIG90aGVyY21kICwgXzEgLCBjbWRkZWZhcmdzICwgXzIgLCBibG9ja3MgLCBfMyBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICBjb25zdCBjbWQgPSBvdGhlcmNtZC5idWZmZXI7XG4gICAgICBsZXQgbmFyZ3MgPSAwO1xuICAgICAgaWYgKGNtZGRlZmFyZ3MucHJvZHVjdGlvbiA9PT0gJ3llcycpIHtcblx0Y29uc3QgWyBfNCAsIHRleHQgLCBfNSBdID0gY21kZGVmYXJncy5jaGlsZHJlbiA7XG5cdG5hcmdzID0gcGFyc2VJbnQodGV4dC5idWZmZXIsIDEwKTtcbiAgICAgIH1cbiAgICAgIHZhcmlhYmxlcy5zZXQoY21kLCBbIG5hcmdzICwgYmxvY2tzIF0pO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0gLFxuXG4gICAgXCJjbWRbeF17YmxvY2tzfVwiOiAoIHRyZWUgLCBfICwgeyB2YXJpYWJsZXMgfSApID0+IHtcbiAgICAgIGNvbnN0IFsgb3RoZXJjbWQgLCBjbWRkZWZhcmdzICwgXzIgLCBibG9ja3MgLCBfMyBdID0gdHJlZS5jaGlsZHJlbiA7XG4gICAgICBjb25zdCBjbWQgPSBvdGhlcmNtZC5idWZmZXI7XG4gICAgICBsZXQgbmFyZ3MgPSAwO1xuICAgICAgaWYgKGNtZGRlZmFyZ3MucHJvZHVjdGlvbiA9PT0gJ3llcycpIHtcblx0Y29uc3QgWyBfNCAsIHRleHQgLCBfNSBdID0gY21kZGVmYXJncy5jaGlsZHJlbiA7XG5cdG5hcmdzID0gcGFyc2VJbnQodGV4dC5idWZmZXIsIDEwKTtcbiAgICAgIH1cbiAgICAgIHZhcmlhYmxlcy5zZXQoY21kLCBbIG5hcmdzICwgYmxvY2tzIF0pO1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0gLFxuXG4gICAgXCIqY21kW3hde2Jsb2Nrc31cIjogKCB0cmVlICwgXyAsIHsgdmFyaWFibGVzIH0gKSA9PiB7XG4gICAgICAvLyBkbyBub3Qga25vdyB3aGF0IHRvIGRvIHdpdGggJyonIGF0IHRoZSBtb21lbnRcbiAgICAgIGNvbnN0IFsgXzEgLCBvdGhlcmNtZCAsIGNtZGRlZmFyZ3MgLCBfMiAsIGJsb2NrcyAsIF8zIF0gPSB0cmVlLmNoaWxkcmVuIDtcbiAgICAgIGNvbnN0IGNtZCA9IG90aGVyY21kLmJ1ZmZlcjtcbiAgICAgIGxldCBuYXJncyA9IDA7XG4gICAgICBpZiAoY21kZGVmYXJncy5wcm9kdWN0aW9uID09PSAneWVzJykge1xuXHRjb25zdCBbIF80ICwgdGV4dCAsIF81IF0gPSBjbWRkZWZhcmdzLmNoaWxkcmVuIDtcblx0bmFyZ3MgPSBwYXJzZUludCh0ZXh0LmJ1ZmZlciwgMTApO1xuICAgICAgfVxuICAgICAgdmFyaWFibGVzLnNldChjbWQsIFsgbmFyZ3MgLCBibG9ja3MgXSk7XG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfSAsXG5cbiAgfSAsXG5cbiAgXCJjbWRkZWZhcmdzXCI6IHtcbiAgICBcInllc1wiIDogZXJyKCBcImNtZGRlZmFyZ3NcIiAsIFwieWVzXCIgKSAsXG4gICAgXCJub1wiIDogZXJyKCBcImNtZGRlZmFyZ3NcIiAsIFwibm9cIiApICxcbiAgfSAsXG5cbiAgXCJjbWQqXCI6IHtcbiAgICBcInllc1wiIDogZXJyKCBcImNtZCpcIiAsIFwieWVzXCIgKSAsXG4gICAgXCJub1wiIDogZXJyKCBcImNtZCpcIiAsIFwibm9cIiApICxcbiAgfSAsXG5cbiAgXCJjbWRvcHRhcmdzXCI6IHtcbiAgICBcInllc1wiIDogZXJyKCBcImNtZG9wdGFyZ3NcIiAsIFwieWVzXCIgKSAsXG4gICAgXCJub1wiIDogZXJyKCBcImNtZG9wdGFyZ3NcIiAsIFwibm9cIiApICxcbiAgfSAsXG5cbiAgXCJjbWRhcmdzXCI6IHtcbiAgICBcImFkZFwiIDogZXJyKCBcImNtZGFyZ3NcIiAsIFwieWVzXCIgKSAsXG4gICAgXCJlbmRcIiA6IGVyciggXCJjbWRhcmdzXCIgLCBcIm5vXCIgKSAsXG4gIH0gLFxuXG59IDtcbiJdfQ==